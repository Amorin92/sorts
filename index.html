<!DOCTYPE HTML>
<html>
	<head>
		<title>ALGORITMOS DE ORDENAÇÃO</title>
		<meta charset="utf-8" />
		<meta name="viewport" content="width=device-width, initial-scale=1, user-scalable=no" />
		<link rel="stylesheet" href="assets/css/main.css" />
		<link rel= "stylesheet" type= "text/css" href= "index.css">
		<script type="text/javascript" src="index.js" defer></script>
		<noscript><link rel="stylesheet" href="assets/css/noscript.css" /></noscript>
	</head>
	<body class="is-preload">
		<script type="text/javascript" src="aos.js"></script>
        <script type="text/javascript" src="base.js"></script>

		<!-- Wrapper -->
			<div id="wrapper">

				<!-- Header -->
					<header id="header">
						
						<div class="content">
							<div class="inner" id="header"><span id="first-header">ALGORITMOS DE</span>
								<span id="second-header">ORDENAÇÃO</span>
								</div>
						<nav>
							<ul>
								<li><a href="#sobre">Sobre</a></li>
								<li><a href="#bubble">Bubble Sort</a></li>
								<li><a href="#merge">Merge Sort</a></li>
								<li><a href="#insertion">Insertion Sort</a></li>
							</ul>
						</nav>
						<nav>
							<ul>
								<li><a href="#selection">Selection Sort</a></li>
								<li><a href="#quick">Quick Sort</a></li>
								<li><a href="#radix">Radix</a></li>
								<li><a href="#shell">Shell Sort</a></li>
							</ul>
						</nav>
						<nav>
							<ul>
								<li><a href="#heap">Heap Sort</a></li>
								<li><a href="#bucket">Bucket Sort</a></li>
								<li><a href="#count">Counting Sort</a></li>
								<li><a href="#compare">comparação</a></li>
							</ul>
						</nav>
					</header>

				<!-- Main -->
					<div id="main">

								</article>
							<article id="sobre">
								<h4 class="major">O que são algoritmos de ordenação?</h4>
								<p>Algoritmo de ordenação, em ciência da computação, é um algoritmo que coloca os elementos de uma dada sequência em uma certa ordem. Em outras palavras efetua sua ordenação completa ou parcial. O objetivo da ordenação é facilitar a recuperação dos dados de uma lista.</p>
								<p>A ordenação de dados é uma técnica de algoritmo muito antiga que nos permite classificar elementos em ordem crescente ou decrescente. Isso viabiliza a logística e nos permite distinguir as propriedades de uma lista na hora de compô-las em sequência numérica ou alfabética. Essa aplicação, geralmente atribuída em dicionários e listas telefônicas, pode ser conferida nas caixas de e-mails, motores de buscas e sistemas de análises comparativas.</p>
								<br>
								<p>Aqui será apresentado 10 tipos diferentes de algoritmos de ordenação.
									Os testes foram realizados com 100.000, 250.000, 500.000 e 1.000.000 de elementos.
									Foi comparado quanto tempo levou para que cada algoritmo realizasse a ordenação.
									As medições de tempo, foram realizadas em segundos.
								</p>
								<p></p>
								<p></p>
								<p></p>
								<p></p>
								
								</article>

							<article id="bubble">
								<h2 class="major">Bubble Sort</h2>
								<p>A classificação por bolha, ou Bubble Sort, é um algoritmo básico para organizar uma sequência de números ou outros elementos na ordem correta. O método funciona examinando cada conjunto de elementos adjacentes na string, da esquerda para a direita, trocando suas posições se estiverem fora de ordem. O algoritmo então repete esse processo até que possa percorrer toda a string e não encontrar dois elementos que precisem ser trocados.</p>
								<p>Como funciona a sua comparação?</p>
								<span class="image main"><img src="images/bubble.jpg" alt="" /></span>
								<h3>Complexidade</h3>
								<li>Caso Médio: Θ(n²)</li>
								<li>Melhor Caso: Θ(n)</li>
								<li>Pior Caso: Θ(n²) </li>
								<br>

								<h3>Código do Bubble Sort</h3>
								<pre>
									<code>
private static void bubbleSort(int vetor[]) {
	boolean troca = true;
	int aux;
		while (troca) {
		troca = false;
		for (int i = 0; i < vetor.length - 1; i++) {
			if (vetor[i] > vetor[i + 1]) {
			aux = vetor[i];
			vetor[i] = vetor[i + 1];
			vetor[i + 1] = aux;
			troca = true;
			}
		}
	}
}
		</code>
	</pre>
	<table>
		<tr>
		<th colspan="5" class="align-center">BUBBLE SORT</th>
		</tr>
			<tr>
				<td>&nbsp;</td>
				<td>100.000</td>
				<td>250.000</td>
			  <td>500.000</td>
				<td>1.000.000</td>
			</tr>
			<tr>
				<td>CASO MÉDIO</td>
				<td>42,2892478</td>
			  <td>223,3793075</td>
			  <td>1.334,3496636</td>
			  <td>2.598,9724951</td>
			</tr>
			<tr>
				<td>MELHOR CASO</td>
				<td>0,0003417</td>
				<td>0,000661</td>
				<td>0,0025173</td>
				<td>0.0017465</td>
			</tr>
			<tr>
				<td>PIOR CASO</td>
				<td>23,94789</td>
				<td>238,7104846</td>
				<td>958,4714887</td>
				<td>1640,931</td>
			</tr>
		</table>
		<span class="image main"><img src="images/grafico_bubble.png" alt="" /></span>
		<p>Os valores apresentados acima estão em <b>segundos</b>, referente ao processamento de cada quantidade de elementos inserida no vetor.</p>					
	</article>


							<article id="merge">
								<h2 class="major">Merge Sort</h2>
								<span class="image merge"><img src="images/Merge_sort_animation2.gif" alt="" /></span>
								<p>
									O merge sort, ou ordenação por mistura, é um exemplo de algoritmo de ordenação por comparação do tipo dividir-para-conquistar.
								</p>
								<p>
									Sua ideia básica consiste em Dividir (o problema em vários subproblemas e resolver esses subproblemas através da recursividade) e Conquistar (após todos os subproblemas terem sido resolvidos ocorre a conquista que é a união das resoluções dos subproblemas). Como o algoritmo Merge Sort usa a recursividade, há um alto consumo de memória e tempo de execução, tornando esta técnica não muito eficiente em alguns problemas.
								</p>
								<h3>Algoritmo</h3>
								<p>
									Os três passos úteis dos algoritmos de divisão e conquista, ou divide and conquer, que se aplicam ao merge sort são:
								</p>
								<li>
									Dividir: Calcula o ponto médio do sub-arranjo, o que demora um tempo constante <img src="images/teta(1).svg">;
								</li>
								<li>
									Conquistar: Recursivamente resolve dois subproblemas, cada um de tamanho n/2, o que contribui com <img src="images/2t.svg"> para o tempo de execução;
								</li>
								<li>
									Combinar: Unir os sub-arranjos em um único conjunto ordenado, que leva o tempo <img src="images/teta(n).svg">
								</li>
								<p><img src="images/formula teta.svg"></p>
								<h3>Complexidade</h3>
								<li>Complexidade de tempo: <img src="images/teta logn.svg"> </li>
								<li>Complexidade de espaço: <img src="images/teta(n).svg"></li>
								<br>
								<h3>Código do Merge Sort</h3>
								<pre>
									<code>
public static void mergeSort(int[] vetor, int tamanho) {
    int elementos = 1;
    int inicio, meio, fim;

    while (elementos < tamanho) {
            inicio = 0;
            while (inicio + elementos < tamanho) {
                meio = inicio + elementos;
                fim = inicio + 2 * elementos;
                if (fim > tamanho) {
                    fim = tamanho;
                }
                intercala(vetor, inicio, meio, fim);
                inicio = fim;
            }
            elementos = elementos * 2;
        }
    }

public static void intercala(int[] vetor, int inicio, int meio, int fim) {
        int novoVetor[] = new int[fim - inicio];
        int i = inicio;
        int m = meio;
        int pos = 0;
        while (i < meio && m < fim) {
            if (vetor[i] <= vetor[m]) {
                novoVetor[pos] = vetor[i];
                pos = pos + 1;
                i = i + 1;
            } else {
                novoVetor[pos] = vetor[m];
                pos = pos + 1;
                m = m + 1;
            }
        }
        while (i < meio) {
            novoVetor[pos] = vetor[i];
            pos = pos + 1;
            i = i + 1;
        }
        while (m < fim) {
            novoVetor[pos] = vetor[m];
            pos = pos + 1;
            m = m + 1;
        }
        for (pos = 0, i = inicio; i < fim; i++, pos++) {
            vetor[i] = novoVetor[pos];
        }
    }
		</code>
	</pre>
	<table>
		<tr>
		<th colspan="5" class="align-center">MERGE SORT</th>
		</tr>
			<tr>
				<td>&nbsp;</td>
				<td>100.000</td>
				<td>250.000</td>
			  <td>500.000</td>
				<td>1.000.000</td>
			</tr>
				<tr>
					<td>CASO MÉDIO</td>
					<td>0,0382017</td>
					  <td>0,0326185</td>
					  <td>0,0715466</td>
					  <td>0,1353109</td>
				</tr>
				<tr>
					<td>MELHOR CASO</td>
					<td>0,0071997</td>
					  <td>0,0141859</td>
					  <td>0,0329194</td>
					  <td>0,0782792</td>
				</tr>
				<tr>
					<td>PIOR CASO</td>
					<td>0,0068417</td>
					  <td>0,0115538</td>
					  <td>0,0315389</td>
					  <td>0,0520813</td>
				</tr>
		</table>
		<span class="image main"><img src="images/grafico_merge.png" alt="" /></span>
		<p>Os valores apresentados acima estão em <b>segundos</b>, referente ao processamento de cada quantidade de elementos inserida no vetor.</p>					
	


							</article>

						</article>
						<article id="insertion">
							<h2 class="major">Insertion Sort</h2>
							<span class="image main"><img src="images/insertion.gif" alt="" /></span>
							<p>Insertion Sort, ou ordenação por inserção, é o algoritmo de ordenação que, dado uma estrutura (array, lista) constrói uma matriz final com um elemento de cada vez, uma inserção por vez. Assim como algoritmos de ordenação quadrática, é bastante eficiente para problemas com pequenas entradas, sendo o mais eficiente entre os algoritmos desta ordem de classificação.</p>
							<p>Podemos fazer uma comparação do Insertion Sort com o modo de como algumas pessoas organizam um baralho num jogo de cartas. Imagine que você está jogando cartas. Você está com as cartas na mão e elas estão ordenadas. Você recebe uma nova carta e deve colocá-la na posição correta da sua mão de cartas, de forma que as cartas obedeçam a ordenação.</p>
							<p>A cada nova carta adicionada a sua mão de cartas, a nova carta pode ser menor que algumas das cartas que você já tem na mão ou maior, e assim, você começa a comparar a nova carta com todas as cartas na sua mão até encontrar sua posição correta. Você insere a nova carta na posição correta, e, novamente, sua mão é composta de cartas totalmente ordenadas. Então, você recebe outra carta e repete o mesmo procedimento. Então outra carta, e outra, e assim por diante, até você não receber mais cartas.</p>
							<p>Esta é a ideia por trás da ordenação por inserção. Percorra as posições do array, começando com o índice 1 (um). Cada nova posição é como a nova carta que você recebeu, e você precisa inseri-la no lugar correto no subarray ordenado à esquerda daquela posição.</p>
							<h3>Complexidade</h3>
							<li>Caso Médio: Θ(n²) </li>
							<li>Melhor Caso: Θ(n) </li>
							<li>Pior Caso: Θ(n²) </li>
							<br>
							<h3>Vantagens e Desvantagens</h3>
								<h4>Vantagens</h4>
							<li>É o método a ser utilizado quando o arquivo está "quase" ordenado</li>
							<li>É um bom método quando se desejar adicionar poucos elementos em um arquivo já ordenado, pois seu custo é linear.</li>
							<li>O algoritmo de ordenação por inserção é estável.</li>
							<br>
								<h4>Desvantagens</h4>
							<li>Alto custo de movimentação de elementos no vetor.</li>
							<br>
							<h3>Código do Insertion Sort</h3>
							<pre>
								<code>
public static void insertionSort(int[] vetor) {
	int j;
	int key;
	int i;
		for (j = 1; j < vetor.length; j++) {
		key = vetor[j];
		for (i = j - 1; (i >= 0) && (vetor[i] > key); i--) {
		vetor[i + 1] = vetor[i];
		}
		vetor[i + 1] = key;
		}
}
	</code>
</pre>
<table>
	<tr>
	<th colspan="5" class="align-center">INSERTION SORT</th>
	</tr>
		<tr>
			<td>&nbsp;</td>
			<td>100.000</td>
			<td>250.000</td>
		    <td>500.000</td>
			<td>1.000.000</td>
		</tr>
		<tr>
			<td>CASO MÉDIO</td>
			<td>0,8990583</td>
		    <td>6,1620409</td>
		    <td>24,4494986</td>
		    <td>106,802170</td>
		</tr>
		<tr>
			<td>MELHOR CASO</td>
			<td>0,0005125</td>
			<td>0,0005884</td>
			<td>0,0015227</td>
			<td>0,0026088</td>
		</tr>
		<tr>
			<td>PIOR CASO</td>
			<td>1,962827</td>
			<td>12,60431</td>
			<td>50,56349</td>
			<td>213,6340</td>
		</tr>
	</table>
	<span class="image main"><img src="images/grafico_insertion.png" alt="" /></span>
	<p>Os valores apresentados acima estão em <b>segundos</b>, referente ao processamento de cada quantidade de elementos inserida no vetor.</p>					

							
							</article>

						<article id="selection">
							<h2 class="major">Selection Sort</h2>
							<span class="image main"><img src="images/selection.gif" alt="" /></span>
							<p>O SelectionSort guarda a posição do menor elemento na variável “menor” e percorre o array procurando por um valor menor. Caso este valor seja encontrado então a variável “menor” recebe a posição deste valor. Por último é checado se a posição do menor elemento é diferente da posição atual, se isso for verdade então é feita uma troca de valores, colocando o menor elemento na frente.</p>
							<br>
							<h3>Complexidade</h3>
							<p>O selection sort compara a cada interação um elemento com os outros, visando encontrar o menor. Dessa forma, podemos entender que não existe um melhor caso mesmo que o vetor esteja ordenado ou em ordem inversa serão executados os dois laços do algoritmo, o externo e o interno. A complexidade deste algoritmo será sempre O(n^2)</p>
							<li>Caso Médio: Θ(n²) </li>
							<li>Melhor Caso: Θ(n²) </li>
							<li>Pior Caso: Θ(n²) </li>
							<br>
							<h3>Vantagens e Desvantagens</h3>
								<h4>Vantagens</h4>
							<li>Ele é um algoritmo simples de ser implementado em comparação aos demais.</li>
							<li>Não necessita de um vetor auxiliar (in-place).</li>
							<li>Por não usar um vetor auxiliar para realizar a ordenação, ele ocupa menos memória.</li>
							<li>Ele é uns dos mais velozes na ordenação de vetores de tamanhos pequenos.</li>
							<br>
								<h4>Desvantagens</h4>
							<li>Ele é um dos mais lentos para vetores de tamanhos grandes.</li>
							<li>Ele não é estável.</li>
							<li>Ele faz sempre ((n²-n)/2) comparações, independentemente do vetor estar ordenado ou não.</li>
							<br>
							<h3>Código do Selection Sort</h3>
							<pre>
								<code>
public static void selectionSort(int[] array) {
	for (int fixo = 0; fixo < array.length - 1; fixo++) {
		int menor = fixo;
								
	for (int i = menor + 1; i < array.length; i++) {
		if (array[i] < array[menor]) {
		menor = i;
			}
		}
		if (menor != fixo) {
		int t = array[fixo];
		array[fixo] = array[menor];
		array[menor] = t;
		}
	}
}
	</code>
</pre>
<table>
	<tr>
	<th colspan="5" class="align-center">SELECION SORT</th>
	</tr>
		<tr>
			<td>&nbsp;</td>
			<td>100.000</td>
			<td>250.000</td>
		    <td>500.000</td>
			<td>1.000.000</td>
		</tr>
		<tr>
			<td>CASO MÉDIO</td>
			<td>3,2590903</td>
		      <td>20,0040132</td>
		      <td>85,7108294</td>
		      <td>326,5103246</td>
		</tr>
		<tr>
			<td>MELHOR CASO</td>
			<td>3,2358392</td>
			<td>20,245482</td>
			<td>83,7553507</td>
			<td>327,1019099</td>
		</tr>
		<tr>
			<td>PIOR CASO</td>
			<td>10,417824</td>
			<td>64,1275469</td>
			<td>264,3673142</td>
			<td>1.025,6812595</td>
		</tr>
	</table>
	<span class="image main"><img src="images/grafico_selection.png" alt="" /></span>
	<p>Os valores apresentados acima estão em <b>segundos</b>, referente ao processamento de cada quantidade de elementos inserida no vetor.</p>					


						</article>


						<article id="quick">
							<h2 class="major">Quick Sort</h2>
							<span class="image main"><img src="images/quick.gif" alt="" /></span>
							<p>O quicksort adota a estratégia de divisão e conquista. A estratégia consiste em rearranjar as chaves de modo que as chaves "menores" precedam as chaves "maiores". Em seguida o quicksort ordena as duas sublistas de chaves menores e maiores recursivamente até que a lista completa se encontre ordenada.</p>
							<p>Os passos são:</p>

								<li>Escolha um elemento da lista, denominado pivô;</li>
								<li>Particiona: rearranje a lista de forma que todos os elementos anteriores ao pivô sejam menores que ele, e todos os elementos posteriores ao pivô sejam maiores que ele. Ao fim do processo o pivô estará em sua posição final e haverá duas sub listas não ordenadas. Essa operação é denominada partição;</li>
								<li>Recursivamente ordene a sub lista dos elementos menores e a sub lista dos elementos maiores;</li>

							<p>O caso base da recursão são as listas de tamanho zero ou um, que estão sempre ordenadas. O processo é finito, pois a cada iteração pelo menos um elemento é posto em sua posição final e não será mais manipulado na iteração seguinte.</p>

							<p>A escolha do pivô e os passos do Particiona podem ser feitos de diferentes formas e a escolha de uma implementação específica afeta fortemente a performance do algoritmo.</p><br>
							<br>
							<h3>Complexidade</h3>
							<li>Caso Médio: Θ(n log n) </li>
							<li>Melhor Caso: Θ(n log n) </li>
							<li>Pior Caso: Θ(n²) </li>
							<br>
								<p>O quick sort é uma versão optimizada de uma árvore binária ordenada. Em vez de introduzir itens sequencialmente numa árvore explicita, o quicksort organiza-os correntemente na árvore onde está implícito, fazendo-o com chamadas recursivas à mesma. O algoritmo faz exactamente as mesmas comparações, mas com uma ordem diferente.</p>
							<br>
							<h3>Código do Quick Sort</h3>
							<pre>
								<code>
public static void quickSort(int[] A){        
	quickSort(A, 0, A.length - 1);
}
								
private static void quickSort(int[] A, int inicio, int fim){        
	if(inicio < fim){
	int q = partition(A, inicio, fim);
	quickSort(A, inicio, q - 1);
	quickSort(A, q + 1, fim);            
	}
}
private static int partition(int[] A, int inicio, int fim){
	Random rnd = new Random();
	int randomIndex = rnd.nextInt(fim - inicio + 1) + inicio;
	swap(A, randomIndex, fim);
	int pivo = A[fim];
	int i = inicio - 1;
		for(int j = inicio; j <= fim - 1; j++){
		if(A[j] <= pivo){
		i = i + 1;
		swap(A, i, j);
			}
		}
	swap(A, i + 1, fim);
	return i + 1;
}

private static void swap(int[] A, int i, int j){
	int temp = A[i];
	A[i] = A[j];
	A[j] = temp;
}
	</code>
</pre>
<table>
	<tr>
	<th colspan="5" class="align-center">QUICK SORT</th>
	</tr>
		<tr>
			<td>&nbsp;</td>
			<td>100.000</td>
			<td>250.000</td>
		    <td>500.000</td>
			<td>1.000.000</td>
		</tr>
		<tr>
			<td>CASO MÉDIO</td>
			<td>0,0215727</td>
		      <td>0,0251514</td>
		      <td>0,0529094</td>
		      <td>0,1076717</td>
		</tr>
		<tr>
			<td>MELHOR CASO</td>
			<td>0,0054925</td>
			<td>0,0142215</td>
			<td>0,0292828</td>
			<td>0,0596236</td>
		</tr>
		<tr>
			<td>PIOR CASO</td>
			<td>0,0060233</td>
			<td>0,0152141</td>
			<td>0,0317578</td>
			<td>0,0632131</td>
		</tr>
	</table>
	<span class="image main"><img src="images/grafico_quick.png" alt="" /></span>
	<p>Os valores apresentados acima estão em <b>segundos</b>, referente ao processamento de cada quantidade de elementos inserida no vetor.</p>					

						
						</article>

					<article id="radix">
						<h2 class="major">RADIX</h2>
						<span class="image main"><img src="images/radix.gif" alt="" /></span>
						<p>O Radix sort é um algoritmo de ordenação rápido e estável que pode ser usado para ordenar itens que estão identificados por chaves únicas. Cada chave é uma cadeia de caracteres ou número, e o radix sort ordena estas chaves em qualquer ordem relacionada com a lexicografia.</p>

						<p>Na ciência da computação, radix sort é um algoritmo de ordenação que ordena inteiros processando dígitos individuais. Como os inteiros podem representar strings compostas de caracteres (como nomes ou datas) e pontos flutuantes especialmente formatados, radix sort não é limitado somente a inteiros.</p>
					

						<p>O RadixSort é um algoritmo de ordenação utilizado em computadores que permitem
							acessar o código binário que representa os caracteres dos números que compõem a sequência
							a ser ordenada (MANBER, 1989).</p>
						<p>Cormen et al. (2009) afirma que o RadixSort é um algoritmo de ordenação rápido e
							estável que pode ser usado para ordenar itens que estão identificados por chaves únicas e que
							cada chave é uma cadeia de caracteres ou número. Nos computadores, estas chaves são os
							números binários usados para representar todo caractere a partir de um conjunto de dados
							binários.</p>
							<p>Embora os sistemas operacionais que permitem o acesso ao código binário não sejam
								convencionais, não será preciso este acesso para implementar o algoritmo, pois a ideia básica
								do RadixSort será aplicada na matriz de incidência e não no código binário. A grande
								vantagem desse algoritmo é que ele ordena em tempo linear, ou seja, Θ(n), qualquer outro 
								algoritmo de ordenação que não goza do artifício de acessar o código binário ordena,
								necessariamente, em pelo menos Θ(n.log n) operações (MANBER, 1989)</p>
					
					<h3>Complexidade assintótica</h3>
					<p>A complexidade no tempo do algoritmo é Θ(nk) e a complexidade no espaço: Θ(n+s), onde:</p>
						<li>n = número de elementos.</li>
						<li>k = = tamanho string.</li>
						<li>s  = tamanho do alfabeto.</li>
					
						<br>
							<h3>Complexidade</h3>
							<li>Caso Médio: Θ(d(n + k))	</li>
							<li>Melhor Caso: Θ(d(n + k)) </li>
							<li>Pior Caso: Θ(d(n + k)) </li>
						<br>
						<h3>Código do RADIX</h3>
						<pre>
							<code>
public static void radix(int[] vetor) {
	for (int digit = 0; digit < 3; digit++) {
	int power = (int) Math.pow(10, digit + 1);
							
	int z[][] = new int[vetor.length][10];
	int n[] = new int[10];
							
	for (int i = 0; i < vetor.length; i++) {
	int num = vetor[i];
	z[n[(num % power) / (power / 10)]][(num % power) / (power / 10)] = num;
	n[(num % power) / (power / 10)]++;
							
	}
	int c = 0;
	for (int i = 0; i < 10; i++) {
							
	for (int j = 0; j < vetor.length; j++) {
	if (j < n[i]) {
	vetor[c] = z[j][i];
	c++;
	} else {
		break;
				}
			}
		}
							
	}
}
</code>
</pre>
<table>
<tr>
<th colspan="5" class="align-center">RADIX</th>
</tr>
	<tr>
		<td>&nbsp;</td>
		<td>100.000</td>
		<td>250.000</td>
		<td>500.000</td>
		<td>1.000.000</td>
	</tr>
	<tr>
		<td>CASO MÉDIO</td>
		<td>0,0267372</td>
		  <td>0,0286562</td>
		  <td>0,0813891</td>
		  <td>0,1204836</td>
	</tr>
	<tr>
		<td>MELHOR CASO</td>
		<td>0,0155682</td>
		  <td>0,0325242</td>
		  <td>0,0561958</td>
		  <td>0,1312999</td>
	</tr>
	<tr>
		<td>PIOR CASO</td>
		<td>0,0129324</td>
		  <td>0,0330549</td>
		  <td>0,0629475</td>
		  <td>0,1292379</td>
	</tr>
</table>
							<span class="image main"><img src="images/grafico_radix.png" alt="" /></span>
							<p>Os valores apresentados acima estão em <b>segundos</b>, referente ao processamento de cada quantidade de elementos inserida no vetor.</p>					

					
					
					</article>


					<article id="shell">
						<h2 class="major">Shell Sort</h2>
						<span class="image merge"><img src="images/shell.gif" alt="" /></span>
						<br>
						<p>Criado por Donald Shell em 1959, publicado pela Universidade de Cincinnati, Shell sort é o mais eficiente algoritmo de classificação dentre os de complexidade quadrática. É um refinamento do método de inserção direta. O algoritmo difere do método de inserção direta pelo fato de no lugar de considerar o array a ser ordenado como um único segmento, ele considera vários segmentos sendo aplicado o método de inserção direta em cada um deles.[3] Basicamente o algoritmo passa várias vezes pela lista dividindo o grupo maior em menores. Nos grupos menores é aplicado o método da ordenação por inserção.</p>
						
						<br>
						<h3>Complexidade</h3>
						<li>Caso Médio: depende da sequencia do gap </li>
						<li>Melhor Caso: Θ(n log2 n) </li>
						<li>Pior Caso: Θ(n log2 n) </li>
						<br>
						<h3>Código do Shell Sort</h3>
						<pre>
							<code>
public static void shellSort(int[] vetor, int quantidade) {
	int i, j, value;
	int gap = 1;
	while (gap < quantidade) {
		gap = 3 * gap + 1;
	}
	while (gap > 1) {
		gap /= 3;
		for (i = gap; i < quantidade; i++) {
			value = vetor[i];
			j = i - gap;
			while (j >= 0 && value < vetor[j]) {
				vetor[j + gap] = vetor[j];
				j -= gap;
			}
			vetor[j + gap] = value;
		}
	}
}
</code>
</pre>
<table>
<tr>
<th colspan="5" class="align-center">SHELL SORT</th>
</tr>
	<tr>
		<td>&nbsp;</td>
		<td>100.000</td>
		<td>250.000</td>
		<td>500.000</td>
		<td>1.000.000</td>
	</tr>
	<tr>
		<td>CASO MÉDIO</td>
		<td>0,0153267</td>
		  <td>0,0351015</td>
		  <td>0,0644998</td>
		  <td>0,1419367</td>
	</tr>
	<tr>
		<td>MELHOR CASO</td>
		<td>0,0012863</td>
		  <td>0,0033718</td>
		  <td>0,0072426</td>
		  <td>0,0150543</td>
	</tr>
	<tr>
		<td>PIOR CASO</td>
		<td>0,0019791</td>
		  <td>0,0053266</td>
		  <td>0,01179</td>
		  <td>0,0231433</td>
	</tr>
</table>
							<span class="image main"><img src="images/grafico_shell.png" alt="" /></span>
							<p>Os valores apresentados acima estão em <b>segundos</b>, referente ao processamento de cada quantidade de elementos inserida no vetor.</p>					

					
					
					
					</article>

				</article>
				<article id="heap">
					<h3 class="major">Heap Sort</h3>
					<span class="image main"><img src="images/heap.gif" alt="" /></span>
					<p>O heapsort utiliza uma estrutura de dados chamada heap, para ordenar os elementos à medida que os insere na estrutura. Assim, ao final das inserções, os elementos podem ser sucessivamente removidos da raiz da heap, na ordem desejada, lembrando-se sempre de manter a propriedade de max-heap.</p>
					<p>A heap pode ser representada como uma árvore (uma árvore binária com propriedades especiais) ou como um vetor. Para uma ordenação decrescente, deve ser construída uma heap mínima (o menor elemento fica na raiz). Para uma ordenação crescente, deve ser construído uma heap máxima (o maior elemento fica na raiz).</p>
					<h3>Complexidade</h3>
					<li>Caso Médio: Θ(n log2 n)</li>
					<li>Melhor Caso: Θ(n log2 n) </li>
					<li>Pior Caso: Θ(n log2 n) </li>
					<br>
					<h3>Código do Heap Sort</h3>
					<pre>
						<code>
public static void heapSort(int[] vetor) {
	int n = vetor.length;
	for (int i = n / 2 - 1; i >= 0; i--) {
		heapify(vetor, n, i);
	}
	for (int i = n - 1; i >= 0; i--) {
		int temp = vetor[0];
		vetor[0] = vetor[i];
		vetor[i] = temp;

		heapify(vetor, i, 0);
	}
}

public static void heapify(int[] arr, int n, int i) {
	int largest = i; 
	int l = 2 * i + 1;
	int r = 2 * i + 2; 

	if (l < n && arr[l] > arr[largest]) {
		largest = l;
	}

	if (r < n && arr[r] > arr[largest]) {
		largest = r;
	}

	if (largest != i) {
		int swap = arr[i];
		arr[i] = arr[largest];
		arr[largest] = swap;

		heapify(arr, n, largest);
	}
}
</code>
</pre>
<table>
<tr>
<th colspan="5" class="align-center">HEAP SORT</th>
</tr>
<tr>
	<td>&nbsp;</td>
	<td>100.000</td>
	<td>250.000</td>
	<td>500.000</td>
	<td>1.000.000</td>
</tr>
<tr>
	<td>CASO MÉDIO</td>
	<td>0,0169982</td>
	  <td>0,0346877</td>
	  <td>0,0693434</td>
	  <td>0,1548323</td>
</tr>
<tr>
	<td>MELHOR CASO</td>
	<td>0,0084088</td>
	  <td>0,0249867</td>
	  <td>0,0426179</td>
	  <td>0,0895642</td>
</tr>
<tr>
	<td>PIOR CASO</td>
	<td>0,0076906</td>
	  <td>0,0264615</td>
	  <td>0,0416095</td>
	  <td>0,0900251</td>
</tr>
</table>
						<span class="image main"><img src="images/grafico_heap.png" alt="" /></span>
						<p>Os valores apresentados acima estão em <b>segundos</b>, referente ao processamento de cada quantidade de elementos inserida no vetor.</p>					




				
				</article>

				<article id="bucket">
					<h2 class="major">Bucket Sort</h2>
					<span class="image main"><img src="images/bucket.gif" alt="" /></span>
					<p>Bucket sort, ou bin sort, é um algoritmo de ordenação que funciona dividindo um vetor em um número finito de recipientes. Cada recipiente é então ordenado individualmente, seja usando um algoritmo de ordenação diferente, ou usando o algoritmo bucket sort recursivamente. </p>
<p>O Bucket Sort tem complexidade linear Θ(n) quando o vetor a ser ordenado contém valores que são uniformemente distribuídos.</p>

                        <h3>Complexidade</h3>
                        <li>Caso Médio: Θ(n+k)</li>
                        <li>Melhor Caso: Θ Θ(n+k)</li>
                        <li>Pior Caso: Θ(n²) </li>
                        <br>


<h3>Funcionamento</h3>
<p>Bucket sort funciona do seguinte modo:</p>
<li> Inicializa um vetor de "baldes", inicialmente vazios.</li>
<li> Vá para o vetor original, incluindo cada elemento em um balde.</li>
<li> Ordene todos os baldes não vazios.</li>
<li> Coloque os elementos dos baldes que não estão vazios no vetor original.</li>

<span class="image main"><img src="images/bucket2.png" alt="" /></span>
<br>

<h3>Código do Bucket Sort</h3>
<pre>
	<code>
public static void bucketSort(float[] arr, int n) {
	if (n <= 0) {
		return;
	}
	@SuppressWarnings("unchecked")
	ArrayList<Float>[] bucket = new ArrayList[n];
	for (int i = 0; i < n; i++) {
		bucket[i] = new ArrayList<>();
	}

	for (int i = 0; i < n; i++) {
		int bucketIndex = (int) arr[i] * n;
		bucket[bucketIndex].add(arr[i]);
	}

	for (int i = 0; i < n; i++) {
		Collections.sort((bucket[i]));
	}

	int index = 0;
	for (int i = 0; i < n; i++) {
		for (int j = 0, size = bucket[i].size(); j < size; j++) {
			arr[index++] = bucket[i].get(j);
		}
	}
}
</code>
</pre>
<table>
<tr>
<th colspan="5" class="align-center">BUCKET SORT</th>
</tr>
<tr>
<td>&nbsp;</td>
<td>100.000</td>
<td>250.000</td>
<td>500.000</td>
<td>1.000.000</td>
</tr>
<tr>
<td>CASO MÉDIO</td>
<td>0,0315158</td>
<td>0,0266823</td>
<td>0,0315869</td>
<td>0,3027816</td>
</tr>
<tr>
<td>MELHOR CASO</td>
<td>0,0071938</td>
<td>0,017939</td>
<td>0,0125623</td>
<td>0,0652403</td>
</tr>
<tr>
<td>PIOR CASO</td>
<td>0,0189336</td>
<td>0,017703</td>
<td>0,0196256</td>
<td>0,022157</td>
</tr>
</table>
	<span class="image main"><img src="images/grafico_bucket.png" alt="" /></span>
	<p>Os valores apresentados acima estão em <b>segundos</b>, referente ao processamento de cada quantidade de elementos inserida no vetor.</p>					

				</article>

				<article id="count">
					<h2 class="major">Counting Sort</h2>
					<span class="image main"><img src="images/count.gif" alt="" /></span>
					<p>É um algoritmo eficiente para classificar uma matriz de elementos que possuem uma chave inteira não negativa, por exemplo, uma matriz, às vezes chamada de lista, de inteiros positivos pode ter chaves que são apenas o valor do inteiro como chave ou uma lista de palavras pode ter chaves atribuídas a elas por algum esquema de mapeamento do alfabeto para números inteiros (para classificar em ordem alfabética, por exemplo). Ao contrário de outros algoritmos de classificação, como <a href="#merge">Merge Sort</a>, a classificação por contagem é um algoritmo de classificação de inteiros, não um algoritmo baseado em comparação. </p>
<p>O counting sort assume que cada um dos n elementos de entrada em uma lista possui um valor de chave variando de 0 a k , para algum número inteiro k . Para cada elemento na lista, a classificação por contagem determina o número de elementos que são menores que ele. A classificação por contagem pode usar essas informações para colocar o elemento diretamente no slot correto da matriz de saída. </p>

<p>A classificação por contagem usa três listas:</p>

<li> A[0,1, ...,n] a lista de entrada. </li>
<li> B[0,1, ...,n] a lista de saída. </li>
<li> C[0,1, ...,k] uma matriz de memória temporária. </li>
<br>

<h3>Como funciona?</h3>

<li> O código calcula o mínimo e o máximo do array A para definir k= max - min + 1. </li>
<li> Para todos os elementos em A[i], 0 <= i <= n - 1, o Count sort, incrementa o valor C[A[i]-min] em um. Por exemplo, considere que o valor 1 na matriz A aparece 8 vezes o valor C [1] = 8. </li>
<li> Atualize o status de C com C[i] = C[i] + C[i-1] , 1 <= i <=k. </li>
<li> Classifica A em B de acordo com C[A[i]], 1<=i<=k e diminua o valor de C[A[i]] após cada atualização. </li>

<span class="image main"><img src="images/count1.gif" alt="" /></span>
<br>

<h3>Complexidade</h3>
<li>Caso Médio: Θ(n+k)</li>
<li>Melhor Caso: Θ(n+k)</li>
<li>Pior Caso: Θ(n+k) </li>

<br>

<h3>Código do Counting Sort</h3>
<pre>
	<code>
public static void countSort(int array[], int size) {
	int[] output = new int[size + 1];
	int max = array[0];
	for (int i = 1; i < size; i++) {
		if (array[i] > max) {
			max = array[i];
		}
	}
	int[] count = new int[max + 1];
	for (int i = 0; i < max; ++i) {
		count[i] = 0;
	}
	for (int i = 0; i < size; i++) {
		count[array[i]]++;
	}
	for (int i = 1; i <= max; i++) {
		count[i] += count[i - 1];
	}

	for (int i = size - 1; i >= 0; i--) {
		output[count[array[i]] - 1] = array[i];
		count[array[i]]--;
	}
	for (int i = 0; i < size; i++) {
		array[i] = output[i];
	}
}
</code>
</pre>
<table>
<tr>
<th colspan="5" class="align-center">COUNTING SORT</th>
</tr>
<tr>
<td>&nbsp;</td>
<td>100.000</td>
<td>250.000</td>
<td>500.000</td>
<td>1.000.000</td>
</tr>
<tr>
<td>CASO MÉDIO</td>
<td>0,0091879</td>
<td>0,005464</td>
<td>0,0058659</td>
<td>0,0228935</td>
</tr>
<tr>
<td>MELHOR CASO</td>
<td>0,001927</td>
<td>0,0053957</td>
<td>0,0044642</td>
<td>0,0266273</td>
</tr>
<tr>
<td>PIOR CASO</td>
<td>0,014158</td>
<td>0,0018607</td>
<td>0,0032986</td>
<td>0,0049884</td>
</tr>
</table>
	<span class="image main"><img src="images/grafico_count.png" alt="" /></span>
	<p>Os valores apresentados acima estão em <b>segundos</b>, referente ao processamento de cada quantidade de elementos inserida no vetor.</p>					



					</article>


				<article id="compare">
					<h3 class="major">Comparação entre os algoritmos</h3>
					<span class="image main"><img src="images/sorts.gif" alt="" /></span>
					<p>Analisando os 10 algoritmos de ordenação nesse site, foi feita uma comparação gráfica entre eles. Sendo uma comparação de todos os algoritmos em caso médio, melhor caso e pior caso.</p>
					<p>A análise foi feita para os seguintes códigos:</p>
					<li><a href="#bubble">Bubble Sort;</a></li>
					<li><a href="#insertion">Insertion Sort;</a></li>
					<li><a href="#selection">Selection Sort;</a></li>
					<li><a href="#merge">Merge Sort;</a></li>
					<li><a href="#quick">Quick Sort;</a></li>
					<li><a href="#radix">Radix;</a></li>
					<li><a href="#shell">Shell Sort;</a></li>
					<li><a href="#heap">Heap Sort;</a></li>
					<li><a href="#bucket">Bucket Sort;</a></li>
					<li><a href="#count">Counting Sort.</a></li>

					<br>
					<h3>Comparação caso médio</h3>
					<br>
					<p>A compração foi dividida em dois gráficos para que fique melhor a visualização da quantidade de segundos para a execução por quantidade de elementos a serem ordenados.</p>
					<div>
						
<table>
	<tr>
	<th colspan="5" class="align-center">CASO MÉDIO 1</th>
	</tr>
		<tr>
			<td>&nbsp;</td>
			<td>100.000</td>
			<td>250.000</td>
			<td>500.000</td>
			<td>1.000.000</td>
		</tr>
		<tr>
			<td>Merge Sort</td>
			<td>0,0382017</td>
			  <td>0,0326185</td>
			  <td>0,0715466</td>
			  <td>0,1353109</td>
		</tr>
		<tr>
			<td>Quick Sort</td>
			<td>0,0215727</td>
			  <td>0,0251514</td>
			  <td>0,0529094</td>
			  <td>0,1076717</td>
		</tr>
		<tr>
			<td>Radix</td>
			<td>0,0267372</td>
			  <td>0,0286562</td>
			  <td>0,0813891</td>
			  <td>0,1204836</td>
		</tr>
		<tr>
			<td>Shell Sort</td>
			<td>0,0153267</td>
			  <td>0,0351015</td>
			  <td>0,0644998</td>
			  <td>0,1419367</td>
		</tr>
		<tr>
			<td>Heap Sort</td>
			<td>0,0169982</td>
			  <td>0,0346877</td>
			  <td>0,0693434</td>
			  <td>0,1548323</td>
		</tr>
		<tr>
			<td>Bucket Sort</td>
			<td>0,0315158</td>
			  <td>0,0266823</td>
			  <td>0,0315869</td>
			  <td>0,3027816</td>
		</tr>
		<tr>
			<td>Counting Sort</td>
			<td>0,0091879</td>
			  <td>0,005464</td>
			  <td>0,0058659</td>
			  <td>0,0228935</td>
		</tr>
	</table>


	
	<span class="image main"><img src="images/grafico_caso_medio1.png" alt="" /></span>
	<p>Os valores apresentados acima estão em <b>segundos</b>, referente ao processamento de cada quantidade de elementos inserida no vetor.</p>					




	<table>
		<tr>
		<th colspan="5" class="align-center">CASO MÉDIO 2</th>
		</tr>
			<tr>
				<td>&nbsp;</td>
				<td>100.000</td>
				<td>250.000</td>
				<td>500.000</td>
				<td>1.000.000</td>
			</tr>
			<tr>
				  <td>Bubble Sort</td>
				  <td>42,2892478</td>
				  <td>223,3793075</td>
				  <td>1334,3496636</td>
				  <td>2598,9724951</td>
			</tr>
			<tr>
				  <td>Insertion Sort</td>
				  <td>0,8990583</td>
				  <td>6,1620409</td>
				  <td>24,4494986</td>
				  <td>106,80217</td>
			</tr>
			<tr>
				  <td>Selection Sort</td>
				  <td>3,2590903</td>
				  <td>20,0040132</td>
				  <td>85,7108294</td>
				  <td>326,5103246</td>
			</tr>
		</table>

		
		<span class="image main"><img src="images/grafico_caso_medio2.png" alt="" /></span>
		<p>Os valores apresentados acima estão em <b>segundos</b>, referente ao processamento de cada quantidade de elementos inserida no vetor.</p>					

	</div>


					<h3>Comparação melhor caso</h3>
					<br>
					<p>A compração foi dividida em dois gráficos para que fique melhor a visualização da quantidade de segundos para a execução por quantidade de elementos a serem ordenados.</p>
					<div>
						
<table>
	<tr>
	<th colspan="5" class="align-center">MELHOR CASO 1</th>
	</tr>
		<tr>
			<td>&nbsp;</td>
			<td>100.000</td>
			<td>250.000</td>
			<td>500.000</td>
			<td>1.000.000</td>
		</tr>
		<tr>
			<td>Merge Sort</td>
			<td>0,0071997</td>
			  <td>0,0141859</td>
			  <td>0,0329194</td>
			  <td>0,0782792</td>
		</tr>
		<tr>
			<td>Quick Sort</td>
			<td>0,0054925</td>
			  <td>0,0142215</td>
			  <td>0,0292828</td>
			  <td>0,0596236</td>
		</tr>
		<tr>
			<td>Radix</td>
			<td>0,0155682</td>
			  <td>0,0325242</td>
			  <td>0,0561958</td>
			  <td>0,1312999</td>
		</tr>
		<tr>
			<td>Shell Sort</td>
			<td>0,0012863</td>
			  <td>0,0033718</td>
			  <td>0,0072426</td>
			  <td>0,0150543</td>
		</tr>
		<tr>
			<td>Heap Sort</td>
			<td>0,0084088</td>
			  <td>0,0249867</td>
			  <td>0,0426179</td>
			  <td>0,0895642</td>
		</tr>
		<tr>
			<td>Bucket Sort</td>
			<td>0,0071938</td>
			  <td>0,017939</td>
			  <td>0,0125623</td>
			  <td>0,0652403</td>
		</tr>
		<tr>
			<td>Counting Sort</td>
			<td>0,001927</td>
			  <td>0,0053957</td>
			  <td>0,0044642</td>
			  <td>0,0266273</td>
		</tr>
	</table>


	
	<span class="image main"><img src="images/grafico_melhor_caso1.png" alt="" /></span>
	<p>Os valores apresentados acima estão em <b>segundos</b>, referente ao processamento de cada quantidade de elementos inserida no vetor.</p>					




	<table>
		<tr>
		<th colspan="5" class="align-center">MELHOR CASO 2</th>
		</tr>
			<tr>
				<td>&nbsp;</td>
				<td>100.000</td>
				<td>250.000</td>
				<td>500.000</td>
				<td>1.000.000</td>
			</tr>
			<tr>
				  <td>Bubble Sort</td>
				  <td>0,0003417</td>
				  <td>0,000661</td>
				  <td>0,0025173</td>
				  <td>0,0017465</td>
			</tr>
			<tr>
				  <td>Insertion Sort</td>
				  <td>0,0005125</td>
				  <td>0,0005884</td>
				  <td>0,0015227</td>
				  <td>0,0026088</td>
			</tr>
			<tr>
				  <td>Selection Sort</td>
				  <td>3,2358392</td>
				  <td>20,245482</td>
				  <td>83,7553507</td>
				  <td>327,1019099</td>
			</tr>
		</table>

		
		<span class="image main"><img src="images/grafico_melhor_caso2.png" alt="" /></span>
		<p>Os valores apresentados acima estão em <b>segundos</b>, referente ao processamento de cada quantidade de elementos inserida no vetor.</p>					



					<h3>Comparação pior caso</h3>
					<br>
					<p>A compração foi dividida em dois gráficos para que fique melhor a visualização da quantidade de segundos para a execução por quantidade de elementos a serem ordenados.</p>
					<div>
						
<table>
	<tr>
	<th colspan="5" class="align-center">PIOR CASO 1</th>
	</tr>
		<tr>
			<td>&nbsp;</td>
			<td>100.000</td>
			<td>250.000</td>
			<td>500.000</td>
			<td>1.000.000</td>
		</tr>
		<tr>
			<td>Merge Sort</td>
			<td>0,0068417</td>
			  <td>0,0115538</td>
			  <td>0,0315389</td>
			  <td>0,0520813</td>
		</tr>
		<tr>
			<td>Quick Sort</td>
			<td>0,0060233</td>
			  <td>0,0152141</td>
			  <td>0,0317578</td>
			  <td>0,0632131</td>
		</tr>
		<tr>
			<td>Radix</td>
			<td>0,0129324</td>
			  <td>0,0330549</td>
			  <td>0,0629475</td>
			  <td>0,1292379</td>
		</tr>
		<tr>
			<td>Shell Sort</td>
			<td>0,0019791</td>
			  <td>0,0053266</td>
			  <td>0,01179</td>
			  <td>0,0231433</td>
		</tr>
		<tr>
			<td>Heap Sort</td>
			<td>0,0076906</td>
			  <td>0,0264615</td>
			  <td>0,0416095</td>
			  <td>0,0900251</td>
		</tr>
		<tr>
			<td>Bucket Sort</td>
			<td>0,0189336</td>
			  <td>0,017703</td>
			  <td>0,0196256</td>
			  <td>0,022157</td>
		</tr>
		<tr>
			<td>Counting Sort</td>
			<td>0,014158</td>
			  <td>0,0018607</td>
			  <td>0,0032986</td>
			  <td>0,0049884</td>
		</tr>
	</table>


	
	<span class="image main"><img src="images/grafico_pior_caso1.png" alt="" /></span>
	<p>Os valores apresentados acima estão em <b>segundos</b>, referente ao processamento de cada quantidade de elementos inserida no vetor.</p>					




	<table>
		<tr>
		<th colspan="5" class="align-center">PIOR CASO 2</th>
		</tr>
			<tr>
				<td>&nbsp;</td>
				<td>100.000</td>
				<td>250.000</td>
				<td>500.000</td>
				<td>1.000.000</td>
			</tr>
			<tr>
				  <td>Bubble Sort</td>
				  <td>23,94789</td>
				  <td>238,7104846</td>
				  <td>958,4714887</td>
				  <td>1640,931</td>
			</tr>
			<tr>
				  <td>Insertion Sort</td>
				  <td>1,962827</td>
				  <td>12,60431</td>
				  <td>50,56349</td>
				  <td>213,634</td>
			</tr>
			<tr>
				  <td>Selection Sort</td>
				  <td>10,417824</td>
				  <td>64,1275469</td>
				  <td>264,3673142</td>
				  <td>1025,6812595</td>
			</tr>
		</table>

		
		<span class="image main"><img src="images/grafico_pior_caso2.png" alt="" /></span>
		<p>Os valores apresentados acima estão em <b>segundos</b>, referente ao processamento de cada quantidade de elementos inserida no vetor.</p>					




				</article>
					
			</div>


					<footer id="footer">
						<p class="copyright">ALUNO: RAFAEL AMORIN - IFMS - TSI - 2022</p>
						<p class="copyright">Análise de algoritmos de ordenação para a disciplina de Estutrura de Dados</p>
					</footer>

			</div>

			<div id="bg"></div>

			<script src="assets/js/jquery.min.js"></script>
			<script src="assets/js/browser.min.js"></script>
			<script src="assets/js/breakpoints.min.js"></script>
			<script src="assets/js/util.js"></script>
			<script src="assets/js/main.js"></script>

	</body>
</html>
